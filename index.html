<!-- Skisim V19 -->
<!-- Tablet & Touch-Optimierung

Das ist eine sehr wichtige Frage! Die bisherige Version funktioniert auf iPads oder Tablets nur eingeschrÃ¤nkt, da diese GerÃ¤te keine Tastatur (fÃ¼r die Pfeiltasten) und keine rechte Maustaste haben. AuÃŸerdem funktionieren Maus-Events (mousedown) auf Touchscreens oft nicht flÃ¼ssig oder gar nicht so, wie man es erwartet.

Damit die App auf dem iPad/Tablet richtig SpaÃŸ macht, mÃ¼ssen wir zwei Dinge tun:

Touch-Events fÃ¼r Drag & Drop: Damit man die Skifahrer mit dem Finger verschieben kann.

On-Screen-Steuerung (Gamepad): Da wir keine Tastatur haben, brauchen wir Buttons auf dem Bildschirm zum Fahren, Drehen und Zoomen.

Hier ist die Version 19, die vollstÃ¤ndig Touch-optimiert ist (aber weiterhin am PC funktioniert).

Das ist neu:
Touch-Drag: Du kannst die Skifahrer mit dem Finger antippen und verschieben.

Bildschirm-Steuerung: Unten gibt es jetzt Buttons fÃ¼r Links/Rechts/Oben/Unten, Drehen und Zoom.
-->


<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ski-Simulation V19 (Touch & Tablet)</title>
    <style>
        /* Wichtig: user-scalable=no im meta tag und touch-action: none verhindern Scrollen/Zoomen durch den Browser */
        body { margin: 0; overflow: hidden; background: #e0e0e0; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; background: #ffffff; touch-action: none; }
        
        .ui { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); max-width: 250px; }
        .key-badge { background: #eee; padding: 2px 6px; border-radius: 4px; border: 1px solid #ccc; font-weight: bold; font-family: monospace; }
        li { margin-bottom: 5px; font-size: 13px; color: #555; }
        h2 { margin: 0 0 10px 0; color: #333; font-size: 18px; }

        #saveBtn {
            margin-top: 10px; padding: 8px; cursor: pointer; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; width: 100%; pointer-events: auto;
        }

        /* --- TOUCH CONTROLS (Gamepad) --- */
        #gamepad {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: none; /* Damit man durch die LÃ¼cken klicken kann */
            align-items: flex-end;
        }

        .control-group {
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 15px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .btn-row { display: flex; gap: 5px; }

        button.touch-btn {
            width: 45px;
            height: 45px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 8px;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            touch-action: manipulation;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        button.touch-btn:active { background: #00bfff; color: white; border-color: #0099cc; }
        
        /* Verstecke Text auf kleinen Handys, falls nÃ¶tig */
        @media (max-height: 500px) { .ui { display: none; } }
    </style>
</head>
<body>

<div class="ui">
    <h2>Ski-Simulation 2026</h2>
    <ul style="margin:0; padding-left: 20px;">
        <li><strong>Tippen:</strong> Skifahrer wÃ¤hlen</li>
        <li><strong>Ziehen:</strong> Verschieben</li>
        <li><strong>Tasten/Touch:</strong> Steuern</li>
    </ul>
    <button id="saveBtn">ðŸ“¸ Speichern</button>
</div>

<div id="gamepad">
    <div class="control-group">
        <span style="font-size:10px; color:#777">Zoom</span>
        <div class="btn-row">
            <button class="touch-btn" id="btnZoomIn">+</button>
            <button class="touch-btn" id="btnZoomOut">-</button>
        </div>
        <span style="font-size:10px; color:#777; margin-top:5px">Drehen</span>
        <div class="btn-row">
            <button class="touch-btn" id="btnRotLeft">â†º</button>
            <button class="touch-btn" id="btnRotRight">â†»</button>
        </div>
    </div>

    <div class="control-group">
        <button class="touch-btn" id="btnUp">â–²</button>
        <div class="btn-row">
            <button class="touch-btn" id="btnLeft">â—€</button>
            <button class="touch-btn" id="btnDown">â–¼</button>
            <button class="touch-btn" id="btnRight">â–¶</button>
        </div>
    </div>
</div>

<canvas id="skiCanvas"></canvas>

<script>
    const canvas = document.getElementById('skiCanvas');
    const ctx = canvas.getContext('2d');
    const saveBtn = document.getElementById('saveBtn');

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if(typeof players !== 'undefined') players.forEach(p => checkBounds(p));
    }
    window.addEventListener('resize', resize);

    // --- SVG ---
    function getSvgString(bodyColor) {
        return `
        <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
            <ellipse cx="50" cy="55" rx="30" ry="10" fill="rgba(0,0,0,0.2)" />
            <rect x="25" y="5" width="12" height="90" rx="5" fill="#333" />
            <rect x="63" y="5" width="12" height="90" rx="5" fill="#333" />
            <circle cx="50" cy="50" r="28" fill="${bodyColor}" stroke="rgba(0,0,0,0.2)" stroke-width="2"/>
            <circle cx="50" cy="50" r="18" fill="#808080" />
            <rect x="38" y="42" width="24" height="10" rx="3" fill="#333" />
            <rect x="40" y="44" width="20" height="6" rx="2" fill="#87ceeb" />
            <line x1="22" y1="50" x2="10" y2="70" stroke="black" stroke-width="2" stroke-linecap="round"/>
            <line x1="78" y1="50" x2="90" y2="70" stroke="black" stroke-width="2" stroke-linecap="round"/>
            <circle cx="22" cy="50" r="5" fill="${bodyColor}" />
            <circle cx="78" cy="50" r="5" fill="${bodyColor}" />
        </svg>`;
    }

    const spriteBlue = new Image(); spriteBlue.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(getSvgString('#3399ff'));
    const spriteGreen = new Image(); spriteGreen.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(getSvgString('#32CD32')); 

    let players = [
        { x: 0, y: 0, width: 100, height: 100, speed: 7, dx: 0, dy: 0, rotation: 0, sprite: spriteBlue, id: 1 },
        { x: 0, y: 0, width: 100, height: 100, speed: 7, dx: 0, dy: 0, rotation: 0, sprite: spriteGreen, id: 2 }
    ];

    let activePlayerIndex = 0; 
    let draggingPlayerIndex = -1; 
    let rotatingPlayerIndex = -1;
    let dragOffset = { x: 0, y: 0 };
    let isSnapping = false;
    let snappingPlayerIndex = -1;
    let targetRotation = 0;

    // Virtuelle Tasten-Status
    const movementKeys = {
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        RotateLeft: false, RotateRight: false, ZoomIn: false, ZoomOut: false
    };

    function init() {
        resize();
        const startY = (canvas.height / 2) - 50;
        players[0].x = (canvas.width / 2) - 150;
        players[0].y = startY;
        players[1].x = (canvas.width / 2) + 50;
        players[1].y = startY;
    }
    init();

    // --- HELPER ---
    function getPlayerUnderMouse(mx, my) {
        for (let i = players.length - 1; i >= 0; i--) {
            const p = players[i];
            if (mx > p.x && mx < p.x + p.width && my > p.y && my < p.y + p.height) return i;
        }
        return -1;
    }
    
    function checkBounds(p) {
        if (p.x < 0) p.x = 0;
        if (p.x > canvas.width - p.width) p.x = canvas.width - p.width;
        if (p.y < 0) p.y = 0;
        if (p.y > canvas.height - p.height) p.y = canvas.height - p.height;
    }

    function performZoom(p, direction, amount) {
        const newWidth = p.width + (direction * amount);
        const newHeight = p.height + (direction * amount);
        if (newWidth > 20 && newHeight > 20) {
            p.x -= (direction * amount) / 2;
            p.y -= (direction * amount) / 2;
            p.width = newWidth;
            p.height = newHeight;
            checkBounds(p);
        }
    }

    // --- UNIFIED INPUT HANDLING (Mouse & Touch) ---
    
    function handleStart(x, y, isRightClick) {
        const idx = getPlayerUnderMouse(x, y);
        if (idx !== -1) {
            const p = players[idx];
            activePlayerIndex = idx; // Fokus setzen
            
            if (isRightClick) {
                rotatingPlayerIndex = idx;
                isSnapping = false;
            } else {
                draggingPlayerIndex = idx;
                dragOffset.x = x - p.x;
                dragOffset.y = y - p.y;
                p.dx = 0; p.dy = 0;
            }
            return true;
        }
        return false;
    }

    function handleMove(x, y) {
        // Cursor
        const idx = getPlayerUnderMouse(x, y);
        if (draggingPlayerIndex !== -1) canvas.style.cursor = 'grabbing';
        else if (idx !== -1) canvas.style.cursor = 'grab';
        else canvas.style.cursor = 'default';

        if (draggingPlayerIndex !== -1) {
            const p = players[draggingPlayerIndex];
            p.x = x - dragOffset.x;
            p.y = y - dragOffset.y;
            checkBounds(p);
        }
    }

    function handleEnd(isRightClick) {
        draggingPlayerIndex = -1;
        if (isRightClick && rotatingPlayerIndex !== -1) {
            const p = players[rotatingPlayerIndex];
            const gridSize = 15;
            let nextSnap = Math.ceil(p.rotation / gridSize) * gridSize;
            targetRotation = nextSnap;
            isSnapping = true;
            snappingPlayerIndex = rotatingPlayerIndex;
            rotatingPlayerIndex = -1;
        }
    }

    // MOUSE EVENTS
    canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY, e.button === 2));
    canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', e => handleEnd(e.button === 2));
    canvas.addEventListener('contextmenu', e => { e.preventDefault(); return false; });
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        performZoom(players[activePlayerIndex], e.deltaY < 0 ? 1 : -1, 5);
    }, { passive: false });

    // TOUCH EVENTS (fÃ¼r Drag & Drop auf Canvas)
    canvas.addEventListener('touchstart', e => {
        // Verhindert Scrollen
        if(e.target === canvas) e.preventDefault();
        const touch = e.touches[0];
        handleStart(touch.clientX, touch.clientY, false);
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
        if(e.target === canvas) e.preventDefault();
        const touch = e.touches[0];
        handleMove(touch.clientX, touch.clientY);
    }, { passive: false });

    canvas.addEventListener('touchend', e => {
        handleEnd(false);
    });

    // --- SCREENSHOT ---
    saveBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `ski-sim-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
    });

    // --- TOUCH CONTROLS (BUTTONS) LOGIK ---
    // Funktion um Buttons mit MovementKeys zu verknÃ¼pfen
    function bindTouchBtn(id, keyName) {
        const btn = document.getElementById(id);
        const startAction = (e) => { e.preventDefault(); movementKeys[keyName] = true; };
        const endAction = (e) => { e.preventDefault(); movementKeys[keyName] = false; };
        
        btn.addEventListener('mousedown', startAction);
        btn.addEventListener('mouseup', endAction);
        btn.addEventListener('mouseleave', endAction);
        btn.addEventListener('touchstart', startAction, {passive:false});
        btn.addEventListener('touchend', endAction, {passive:false});
    }

    bindTouchBtn('btnUp', 'ArrowUp');
    bindTouchBtn('btnDown', 'ArrowDown');
    bindTouchBtn('btnLeft', 'ArrowLeft');
    bindTouchBtn('btnRight', 'ArrowRight');
    bindTouchBtn('btnRotLeft', 'RotateLeft');
    bindTouchBtn('btnRotRight', 'RotateRight');
    bindTouchBtn('btnZoomIn', 'ZoomIn');
    bindTouchBtn('btnZoomOut', 'ZoomOut');


    // --- KEYBOARD ---
    window.addEventListener('keydown', (e) => {
        if (e.key === 's' || e.key === 'S') { saveBtn.click(); return; }
        if (e.code === 'Tab') {
            e.preventDefault();
            activePlayerIndex = (activePlayerIndex + 1) % players.length;
            return;
        }
        if(movementKeys.hasOwnProperty(e.code)) movementKeys[e.code] = true;
        // Map old keys
        if (e.key === 'Ã¶' || e.key === 'Ã–') movementKeys['RotateLeft'] = true;
        if (e.key === 'Ã¤' || e.key === 'Ã„') movementKeys['RotateRight'] = true;
        if (e.key === '+') movementKeys['ZoomIn'] = true;
        if (e.key === '-') movementKeys['ZoomOut'] = true;
    });

    window.addEventListener('keyup', (e) => {
        if(movementKeys.hasOwnProperty(e.code)) movementKeys[e.code] = false;
        if (e.key === 'Ã¶' || e.key === 'Ã–') movementKeys['RotateLeft'] = false;
        if (e.key === 'Ã¤' || e.key === 'Ã„') movementKeys['RotateRight'] = false;
        if (e.key === '+') movementKeys['ZoomIn'] = false;
        if (e.key === '-') movementKeys['ZoomOut'] = false;
    });


    // --- GAME LOOP ---
    function update() {
        // Manuelle Rotation (Rechtsklick Maus)
        if (rotatingPlayerIndex !== -1) players[rotatingPlayerIndex].rotation += 3;
        
        // Snap
        if (isSnapping && snappingPlayerIndex !== -1) {
            const p = players[snappingPlayerIndex];
            let diff = targetRotation - p.rotation;
            if (diff <= 0) { p.rotation = targetRotation; isSnapping = false; snappingPlayerIndex = -1; }
            else { p.rotation += (diff < 3 ? diff : 3); }
        }

        // Steuerung aktiver Spieler (Tastatur ODER Touch-Buttons)
        const activeP = players[activePlayerIndex];
        // Nur bewegen, wenn nicht gedraggt wird
        if (draggingPlayerIndex !== activePlayerIndex) {
            // Fahren
            if (movementKeys['ArrowLeft']) activeP.dx = -activeP.speed;
            else if (movementKeys['ArrowRight']) activeP.dx = activeP.speed;
            else activeP.dx *= 0.85; 

            if (movementKeys['ArrowUp']) activeP.dy = -activeP.speed;
            else if (movementKeys['ArrowDown']) activeP.dy = activeP.speed;
            else activeP.dy *= 0.85; 

            activeP.x += activeP.dx;
            activeP.y += activeP.dy;

            // Drehen (Keys/Buttons)
            if (movementKeys['RotateLeft']) activeP.rotation -= 3;
            if (movementKeys['RotateRight']) activeP.rotation += 3;

            // Zoom (Keys/Buttons)
            if (movementKeys['ZoomIn']) performZoom(activeP, 1, 3);
            if (movementKeys['ZoomOut']) performZoom(activeP, -1, 3);

            checkBounds(activeP);
        }
    }

    function draw() {
        let gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 100, canvas.width/2, canvas.height/2, canvas.width);
        gradient.addColorStop(0, '#ffffff'); gradient.addColorStop(1, '#ebeff5'); 
        ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);

        players.forEach((p, index) => {
            if (p.sprite.complete) {
                ctx.save(); 
                ctx.translate(p.x + p.width/2, p.y + p.height/2);
                if (index === activePlayerIndex) {
                    ctx.beginPath(); ctx.arc(0, 0, Math.max(p.width, p.height)/1.5, 0, Math.PI*2);
                    ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); ctx.stroke();
                }
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.drawImage(p.sprite, -p.width/2, -p.height/2, p.width, p.height);
                ctx.restore(); 
            }
        });
        requestAnimationFrame(() => { update(); draw(); });
    }
    draw();
</script>
</body>
</html>