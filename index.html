<!-- Skisim V59 -->
<!-- Textbox improved for touch

Apache V2 License
2026-01-04 
Christian Klingler, asolvo 
erstellt mit Google Gemini 3 Pro 

Deine Idee mit dem doppelten Antippen (Double Tap) ist tatsÃ¤chlich die beste und intuitivste LÃ¶sung. Das ist ein Standard-Interaktionsmuster (bekannt aus Apps wie Instagram, Miro oder Grafikprogrammen), um in den "Bearbeitungsmodus" eines Objekts zu gelangen.

Es ist besser als ein zusÃ¤tzlicher Button, da es die OberflÃ¤che sauber hÃ¤lt.

Hier ist Version 60.

Die Ã„nderungen:
Double-Tap / Doppelklick Logik:

Ich habe in die Funktion handleStart (die bei Maus-Klick und Touch-Start feuert) eine Zeitmessung eingebaut.

Wenn du ein Text-Objekt zweimal innerhalb von 300 Millisekunden antippst (oder anklickst), Ã¶ffnet sich das Eingabefenster sofort.

Code-Optimierung:

Die Logik zum Ã–ffnen des Fensters wurde in eine eigene Funktion openTextEditor(object) ausgelagert. Diese wird nun sowohl von der Enter-Taste als auch vom Doppelklick aufgerufen.

UI-Hinweis:

In der Info-Box steht nun: "Text: Markieren & Enter / Doppelklick".

Hier ist der vollstÃ¤ndige Code:
-->




<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ski-Simulation V60 (Touch Text Edit)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #e0e0e0; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; background: #ffffff; touch-action: none; }
        
        /* UI */
        .ui { 
            position: absolute; top: 20px; left: 20px; pointer-events: auto; 
            background: rgba(255,255,255,0.95); border-radius: 12px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); width: 280px; z-index: 20; 
            overflow: hidden; transition: height 0.3s ease;
        }
        .ui-header { padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; border-bottom: 1px solid #eee; user-select: none; }
        .ui-header:hover { background: #f1f3f5; }
        .ui-header h2 { margin: 0; font-size: 18px; color: #333; }
        .toggle-icon { font-size: 14px; color: #666; transition: transform 0.3s; }
        .ui.collapsed .toggle-icon { transform: rotate(-90deg); }
        .ui.collapsed .ui-content { display: none; }
        .ui-content { padding: 15px; }
        .key-badge { background: #eee; padding: 2px 6px; border-radius: 4px; border: 1px solid #ccc; font-weight: bold; font-family: monospace; }
        li { margin-bottom: 8px; font-size: 14px; color: #555; line-height: 1.4; }

        /* HEADER BUTTONS */
        .header-btn { 
            position: absolute; top: 20px; 
            width: 50px; height: 50px; cursor: pointer; background: white; 
            border: none; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 20;
            font-size: 24px; display: flex; justify-content: center; align-items: center;
            transition: transform 0.1s, background 0.2s;
        }
        .header-btn:hover { background: #f8f9fa; transform: scale(1.05); }
        .header-btn:active { transform: scale(0.95); background: #e9ecef; }
        
        #saveBtn { right: 125px; }
        #shareBtn { right: 185px; }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 9999; display: flex; justify-content: center; align-items: center;
            font-size: 24px; color: #333; font-weight: bold;
        }

        /* Dock */
        #dock {
            position: absolute; top: 20px; right: 20px; width: 90px;
            background: rgba(255,255,255,0.9); border-radius: 12px; padding: 15px 10px;
            display: flex; flex-direction: column; gap: 20px; align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 20;
            transition: background 0.2s, transform 0.2s;
            max-height: 80vh; overflow-y: auto;
        }
        #dock:hover { background: rgba(255,255,255,1); transform: scale(1.02); }
        .dock-title { font-size: 13px; font-weight: bold; color: #555; text-align: center; margin-bottom: 5px; }
        .dock-item {
            width: 70px; height: 70px; border: 2px dashed #ccc; border-radius: 10px;
            cursor: grab; display: flex; justify-content: center; align-items: center;
            background: #f9f9f9; touch-action: none; position: relative; flex-shrink: 0;
        }
        .dock-item:active { cursor: grabbing; border-color: #00bfff; background: #eef; }
        .dock-item img { pointer-events: none; width: 100%; height: 100%; object-fit: contain; }
        .color-box { width: 40px !important; height: 50px !important; display: block; margin: auto; border: 1px solid #999; }
        .text-preview { font-family: Arial, sans-serif; font-weight: bold; font-size: 20px; color: #333; pointer-events: none; }

        #ghost-drag { position: absolute; pointer-events: none; opacity: 0.8; z-index: 100; display: none; width: 80px; height: 80px; object-fit: contain; }
        
        #gamepad { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; pointer-events: none; align-items: flex-end; z-index: 20; }
        .control-group { background: rgba(255,255,255,0.8); padding: 10px; border-radius: 15px; pointer-events: auto; display: flex; flex-direction: column; align-items: center; gap: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .btn-row { display: flex; gap: 5px; }
        button.touch-btn { width: 45px; height: 45px; border: 1px solid #ccc; background: white; border-radius: 8px; font-size: 20px; font-weight: bold; color: #333; cursor: pointer; touch-action: manipulation; user-select: none; display: flex; justify-content: center; align-items: center; }
        button.touch-btn:active { background: #00bfff; color: white; border-color: #0099cc; }
        
        @media (max-height: 500px) { .ui { display: none; } }
    </style>
</head>
<body>

<div id="loader">Lade Simulation...</div>

<div class="ui" id="instructionBox">
    <div class="ui-header" onclick="toggleUI()">
        <h2>Ski-Simulation</h2>
        <span class="toggle-icon">â–¼</span>
    </div>
    <div class="ui-content">
        <ul style="margin:0; padding-left: 20px;">
            <li><strong>Objekte:</strong> Ziehen zum HinzufÃ¼gen.</li>
            <li><strong>Text:</strong> Markieren & <span class="key-badge">Enter</span> oder <strong>Doppelklick</strong>.</li>
            <li><strong>Verschieben:</strong> Maus/Touch.</li>
            <li><strong>Drehen:</strong> Rechte Maustaste / <span class="key-badge">Ã¶</span> <span class="key-badge">Ã¤</span>.</li>
            <li><strong>Zoomen:</strong> Mausrad / <span class="key-badge">+</span> <span class="key-badge">-</span>.</li>
            <li><strong>Wechseln:</strong> <span class="key-badge">Tab</span>.</li>
        </ul>
        <div style="margin-top: 12px; font-size: 10px; color: #bbb; text-align: right;">v60</div>
    </div>
</div>

<button id="shareBtn" class="header-btn" title="Teilen">
    <svg viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle>
        <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
    </svg>
</button>
<button id="saveBtn" class="header-btn" title="Download">ðŸ“¥</button>

<div id="dock">
    <div class="dock-title">Objekte</div>
</div>

<img id="ghost-drag" src="" alt="box">

<div id="gamepad">
    <div class="control-group">
        <span style="font-size:10px; color:#777">Zoom</span>
        <div class="btn-row"><button class="touch-btn" id="btnZoomIn">+</button><button class="touch-btn" id="btnZoomOut">-</button></div>
        <span style="font-size:10px; color:#777; margin-top:5px">Drehen</span>
        <div class="btn-row"><button class="touch-btn" id="btnRotLeft">â†º</button><button class="touch-btn" id="btnRotRight">â†»</button></div>
    </div>
    <div class="control-group">
        <button class="touch-btn" id="btnUp">â–²</button>
        <div class="btn-row"><button class="touch-btn" id="btnLeft">â—€</button><button class="touch-btn" id="btnDown">â–¼</button><button class="touch-btn" id="btnRight">â–¶</button></div>
    </div>
</div>

<canvas id="skiCanvas"></canvas>

<script>
    function toggleUI() { document.getElementById('instructionBox').classList.toggle('collapsed'); }

    // --- ASSETS ---
    const SVG_SKI_BLUE = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect x="35" y="5" width="12" height="90" rx="5" fill="#333"/><rect x="53" y="5" width="12" height="90" rx="5" fill="#333"/><rect x="30" y="33" width="40" height="34" rx="12" fill="#3399ff" stroke="#0056b3" stroke-width="2"/><circle cx="50" cy="50" r="14" fill="#808080"/><rect x="38" y="42" width="24" height="10" rx="3" fill="#333"/><rect x="40" y="44" width="20" height="6" rx="2" fill="#87ceeb"/><line x1="28" y1="50" x2="25" y2="70" stroke="black" stroke-width="2" stroke-linecap="round"/><line x1="72" y1="50" x2="75" y2="70" stroke="black" stroke-width="2" stroke-linecap="round"/><circle cx="28" cy="50" r="7" fill="#3399ff"/><circle cx="72" cy="50" r="7" fill="#3399ff"/></svg>`);
    const SVG_SKI_GREEN = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect x="35" y="5" width="12" height="90" rx="5" fill="#333"/><rect x="53" y="5" width="12" height="90" rx="5" fill="#333"/><rect x="30" y="33" width="40" height="34" rx="12" fill="#32CD32" stroke="#228B22" stroke-width="2"/><circle cx="50" cy="50" r="14" fill="#808080"/><rect x="38" y="42" width="24" height="10" rx="3" fill="#333"/><rect x="40" y="44" width="20" height="6" rx="2" fill="#87ceeb"/><line x1="28" y1="50" x2="25" y2="70" stroke="black" stroke-width="2" stroke-linecap="round"/><line x1="72" y1="50" x2="75" y2="70" stroke="black" stroke-width="2" stroke-linecap="round"/><circle cx="28" cy="50" r="7" fill="#32CD32"/><circle cx="72" cy="50" r="7" fill="#32CD32"/></svg>`);
    const SVG_BOARDER = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><ellipse cx="50" cy="55" rx="35" ry="12" fill="rgba(0,0,0,0.2)"/><path d="M 5 38 Q 50 34 95 38 L 98 40 Q 102 50 98 60 L 95 62 Q 50 66 5 62 L 2 60 Q -2 50 2 40 Z" fill="#81ae98" stroke="#5a7a6a" stroke-width="1"/><rect x="15" y="40" width="12" height="20" rx="4" fill="#222"/><rect x="73" y="40" width="12" height="20" rx="4" fill="#222"/><ellipse cx="50" cy="50" rx="22" ry="14" fill="#b83dba" stroke="#8a2e8c" stroke-width="2"/><circle cx="50" cy="50" r="14" fill="#808080"/><rect x="38" y="38" width="24" height="8" rx="3" fill="#333"/><rect x="40" y="39" width="20" height="6" rx="2" fill="#87ceeb"/><path d="M 28 50 L 15 48" stroke="#b83dba" stroke-width="10" stroke-linecap="round" fill="none"/><path d="M 72 50 L 85 48" stroke="#b83dba" stroke-width="10" stroke-linecap="round" fill="none"/><circle cx="15" cy="48" r="6" fill="#111"/><circle cx="85" cy="48" r="6" fill="#111"/></svg>`);
    const SVG_TREE = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M50 5 L65 20 L95 15 L80 50 L90 85 L65 80 L50 95 L35 80 L10 85 L20 50 L5 15 L35 20 Z" fill="#0a2915" stroke="#051f0e" stroke-width="1" stroke-linejoin="round"/><path d="M50 12 L58 35 L85 28 L70 48 L92 68 L65 65 L50 92 L35 65 L8 68 L30 48 L15 28 L42 35 Z" fill="#1a472a" stroke="#0e2b18" stroke-width="1" stroke-linejoin="round" transform="rotate(5 50 50)"/><path d="M50 22 L60 40 L82 38 L68 52 L80 72 L50 68 L20 72 L32 52 L18 38 L40 40 Z" fill="#2e7d32" stroke="#1b5e20" stroke-width="1" stroke-linejoin="round" transform="rotate(20 50 50)"/><path d="M50 32 L58 45 L75 42 L62 55 L70 72 L50 65 L30 72 L38 55 L25 42 L42 45 Z" fill="#4caf50" stroke="#388e3c" stroke-width="1" stroke-linejoin="round" transform="rotate(-10 50 50)"/><circle cx="50" cy="50" r="5" fill="#81c784"/></svg>`);
    const SVG_LINE = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20" viewBox="0 0 200 20"><line x1="5" y1="10" x2="195" y2="10" stroke="#808080" stroke-width="3" stroke-linecap="round" /></svg>`);
    const SVG_ARROW = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="40" viewBox="0 0 100 40"><line x1="5" y1="20" x2="85" y2="20" stroke="#3399ff" stroke-width="6" stroke-linecap="round"/><path d="M 95 20 L 75 10 L 75 30 Z" fill="#3399ff" /></svg>`);
    const SVG_V = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="60" viewBox="0 0 100 60"><path d="M 5 5 L 50 50 L 95 5" stroke="#808080" stroke-width="3" stroke-linecap="round" fill="none"/></svg>`);
    
    // CUSTOM INKSCAPE PFLUGFAHRER (Detailed)
    const SVG_SKI_PLOW = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="37.023964" y="35.509697" width="12" height="72" rx="5" fill="#81ae98" transform="rotate(-25)"/><rect x="41.606819" y="-6.7521315" width="12" height="72" rx="5" fill="#81ae98" transform="rotate(25)"/><rect x="29.947439" y="34.780109" width="40.105122" height="30.439781" rx="12.031537" fill="#3399ff" stroke="#0056b3" stroke-width="1.89488"/><circle cx="50" cy="50" r="14" fill="#808080"/><rect x="38" y="42" width="24" height="10" rx="3" fill="#333"/><rect x="40" y="44" width="20" height="6" rx="2" fill="#87ceeb"/><circle cx="28" cy="50" r="7" fill="#3399ff"/><circle cx="72.856575" cy="42.936256" r="5.3266931" fill="#333"/><circle cx="72" cy="50" r="7" fill="#3399ff"/><circle cx="72.398407" cy="46.840637" r="7" fill="#3399ff"/><circle cx="27.282869" cy="43.219124" r="5.0876493" fill="#333"/><circle cx="27.537849" cy="47.868526" r="7" fill="#3399ff"/><path fill="#826dff" stroke="#544bb3" stroke-width="0.0710732" stroke-linecap="round" stroke-linejoin="round" d="m 26.698432,56.845502 c -0.667894,-0.131 -1.566917,-0.473694 -2.160106,-0.823398 -1.898546,-1.119258 -3.065111,-2.867871 -3.459405,-5.185451 -0.0671,-0.394422 -0.198227,-0.986055 -0.291385,-1.314741 -0.241444,-0.851876 -0.244849,-2.32468 -0.0076,-3.283606 1.169417,-4.726449 6.66981,-6.835578 10.69416,-4.100681 0.531849,0.361438 1.32698,1.144604 1.712851,1.687076 0.661537,0.930017 1.048532,1.903386 1.267196,3.187251 0.05971,0.350598 0.18942,0.924303 0.28824,1.274901 0.249474,0.885096 0.256045,2.506428 0.01379,3.402268 -0.360517,1.333155 -1.008202,2.413352 -2.027714,3.381789 -0.943482,0.896216 -2.047984,1.472984 -3.342006,1.74519 -0.59985,0.126183 -2.110363,0.142705 -2.688026,0.0294 z"/><path fill="#826dff" d="m 70.55556,56.815465 c -1.272123,-0.292075 -2.367548,-0.873992 -3.284024,-1.744555 -1.020379,-0.96926 -1.669683,-2.047432 -2.022137,-3.357763 -0.244882,-0.910404 -0.243566,-2.525074 0.0028,-3.426294 0.120106,-0.43937 0.183234,-0.934571 0.203156,-1.593626 0.05825,-1.927187 0.812842,-3.642411 2.145459,-4.876761 3.920014,-3.630949 10.123656,-1.865147 11.534362,3.283136 0.247704,0.903982 0.25338,2.507979 0.01226,3.466135 -0.104144,0.413853 -0.186133,1.049203 -0.210791,1.633466 -0.127233,3.014686 -1.99193,5.494622 -4.833055,6.427674 -0.681537,0.223823 -0.87211,0.251101 -1.912351,0.27373 -0.783305,0.01704 -1.310051,-0.01038 -1.635675,-0.08514 z"/></svg>`);
    
    // CUSTOM INKSCAPE INJURED
    const SVG_INJURED = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="m 35,55 c -6.666667,10 0.689243,33.122178 2.689243,39.788845 l 11.298805,0.215139 C 44.225764,81.585658 46.666667,66.666667 50,60 Z" fill="#333333"/><path d="m 55,55 c 6.666667,10 3.836654,34.269588 1.836654,40.936255 L 49.298805,94.430279 C 45.965472,86.430279 43.333333,66.666667 40,60 Z" fill="#333333"/><path d="M 33.952191,33.569721 C 47.285525,20.236388 56.666667,16.666667 70,30 67.742364,43.652058 68.179283,51.229748 60.155378,60.063745 L 35,60 C 25,53.333333 28.90571,51.447543 30.207171,41.721116 Z" fill="#d9534f" stroke="#c9302c" stroke-width="2" stroke-linejoin="round"/><path d="M 41.880478,28.167331 C 37.213811,34.833997 30.309429,45.203187 35,58" stroke="#a32623" stroke-width="5" stroke-linecap="round" fill="none"/><path d="m 66.884462,44.868525 c 2.209827,6.475432 0.140771,8.494024 -2.50996,18.358566" stroke="#a32623" stroke-width="5" stroke-linecap="round" fill="none"/><circle cx="70" cy="30" r="14" fill="#808080" stroke="#666" stroke-width="1"/></svg>`);


    const ASSETS = { 
        skiBlue: new Image(), skiGreen: new Image(), boarder: new Image(), tree: new Image(),
        lineGray: new Image(), arrowBlue: new Image(), vShape: new Image(),
        skiPlow: new Image(), injured: new Image()
    };
    
    const TEMPLATES = [
        { type: 'sprite', assetKey: 'skiBlue', width: 100, height: 100, rotation: 0 },
        { type: 'sprite', assetKey: 'skiGreen', width: 100, height: 100, rotation: 0 },
        { type: 'sprite', assetKey: 'skiPlow', width: 100, height: 100, rotation: 0 },
        { type: 'sprite', assetKey: 'boarder', width: 100, height: 100, rotation: 90 },
        { type: 'sprite', assetKey: 'injured', width: 100, height: 100, rotation: 0 },
        { type: 'sprite', assetKey: 'tree', width: 120, height: 120, rotation: 0 }, 
        { type: 'text', text: 'Text', color: '#000000', width: 80, height: 30, rotation: 0 },
        { type: 'sprite', assetKey: 'lineGray', width: 200, height: 20, rotation: 0 },
        { type: 'sprite', assetKey: 'arrowBlue', width: 100, height: 40, rotation: 0 },
        { type: 'sprite', assetKey: 'vShape', width: 100, height: 60, rotation: 0 },
        { type: 'rect', color: '#808080', width: 80, height: 120, rotation: 0 }
    ];

    const canvas = document.getElementById('skiCanvas');
    const ctx = canvas.getContext('2d');
    const dockContainer = document.getElementById('dock');
    const ghostDrag = document.getElementById('ghost-drag');
    const loader = document.getElementById('loader');

    let activeObjects = [], dockedObjects = [], activePlayerIndex = 0; 
    let draggingPlayerIndex = -1, rotatingPlayerIndex = -1, dragOffset = { x: 0, y: 0 };
    let isSnapping = false, snappingPlayerIndex = -1, targetRotation = 0, dragFromDockItem = null; 
    let lastTapTime = 0;

    function preloadAssets(callback) {
        let loaded = 0; const total = 9; let started = false;
        function checkDone() { loaded++; if (loaded === total && !started) { started = true; callback(); } }
        const keys = Object.keys(ASSETS);
        keys.forEach(k => { ASSETS[k].onload = checkDone; ASSETS[k].onerror = checkDone; });
        ASSETS.skiBlue.src = SVG_SKI_BLUE; ASSETS.skiGreen.src = SVG_SKI_GREEN; ASSETS.boarder.src = SVG_BOARDER;
        ASSETS.tree.src = SVG_TREE; ASSETS.lineGray.src = SVG_LINE; ASSETS.arrowBlue.src = SVG_ARROW; ASSETS.vShape.src = SVG_V;
        ASSETS.skiPlow.src = SVG_SKI_PLOW; ASSETS.injured.src = SVG_INJURED;
        setTimeout(() => { if(!started) { console.warn("Safety start."); started = true; callback(); } }, 500);
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; activeObjects.forEach(p => checkBounds(p)); }
    window.addEventListener('resize', resize);

    function startGame() {
        loader.style.display = 'none';
        resize();
        activeObjects.push(createObject(TEMPLATES[0], canvas.width/2 - 50, canvas.height/2 - 50));
        dockedObjects = TEMPLATES.slice(1);
        renderDock();
        requestAnimationFrame(drawLoop);
    }

    function createObject(tpl, x, y) {
        let obj = { type: tpl.type, x: x, y: y, width: tpl.width, height: tpl.height, rotation: tpl.rotation, speed: 7, dx: 0, dy: 0 };
        if(tpl.type === 'sprite') obj.assetKey = tpl.assetKey; 
        else if(tpl.type === 'text') { obj.text = tpl.text; obj.color = tpl.color; }
        else obj.color = tpl.color;
        return obj;
    }

    function renderDock() {
        dockContainer.innerHTML = '<div class="dock-title">Objekte</div>';
        dockedObjects.forEach((tpl, index) => {
            const el = document.createElement('div'); el.className = 'dock-item';
            if (tpl.type === 'sprite') { 
                const img = document.createElement('img'); img.src = ASSETS[tpl.assetKey].src; el.appendChild(img); 
            } else if (tpl.type === 'text') {
                const sp = document.createElement('span'); sp.className = 'text-preview'; sp.innerText = 'T'; el.appendChild(sp);
            } else { 
                const box = document.createElement('div'); box.className = 'color-box'; box.style.background = tpl.color; el.appendChild(box); 
            }
            const startHandler = (e) => handleDockDragStart(e, tpl, index);
            el.addEventListener('mousedown', startHandler); el.addEventListener('touchstart', startHandler, {passive: false});
            dockContainer.appendChild(el);
        });
    }

    function handleDockDragStart(e, tpl, index) {
        e.preventDefault(); dragFromDockItem = { tpl: tpl, index: index };
        if (tpl.type === 'sprite') { 
            ghostDrag.src = ASSETS[tpl.assetKey].src; ghostDrag.style.background = 'transparent'; 
        } else if (tpl.type === 'text') {
            ghostDrag.src = ''; ghostDrag.style.background = 'white'; ghostDrag.style.border = '1px solid black'; ghostDrag.style.borderRadius = '4px';
        } else { 
            ghostDrag.src = ''; ghostDrag.style.backgroundColor = tpl.color; 
        }
        ghostDrag.style.display = 'block'; moveGhost(getClientPos(e));
        document.addEventListener('mousemove', handleDockDragMove); document.addEventListener('touchmove', handleDockDragMove, {passive: false});
        document.addEventListener('mouseup', handleDockDragEnd); document.addEventListener('touchend', handleDockDragEnd);
    }
    function getClientPos(e) { if(e.touches && e.touches.length > 0) return { x: e.touches[0].clientX, y: e.touches[0].clientY }; return { x: e.clientX, y: e.clientY }; }
    function moveGhost(pos) { ghostDrag.style.left = (pos.x - 40) + 'px'; ghostDrag.style.top = (pos.y - 40) + 'px'; }
    function handleDockDragMove(e) { if (!dragFromDockItem) return; e.preventDefault(); moveGhost(getClientPos(e)); }
    function handleDockDragEnd(e) {
        document.removeEventListener('mousemove', handleDockDragMove); document.removeEventListener('touchmove', handleDockDragMove);
        document.removeEventListener('mouseup', handleDockDragEnd); document.removeEventListener('touchend', handleDockDragEnd);
        ghostDrag.style.display = 'none'; if (!dragFromDockItem) return;
        let pos = getClientPos(e); if (e.changedTouches && e.changedTouches.length > 0) pos = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
        if (pos.x < window.innerWidth - 120) {
            activeObjects.push(createObject(dragFromDockItem.tpl, pos.x - 50, pos.y - 50));
            dockedObjects.splice(dragFromDockItem.index, 1); renderDock(); activePlayerIndex = activeObjects.length - 1;
        }
        dragFromDockItem = null;
    }

    function checkBounds(p) { if (p.x < 0) p.x = 0; if (p.x > canvas.width - p.width) p.x = canvas.width - p.width; if (p.y < 0) p.y = 0; if (p.y > canvas.height - p.height) p.y = canvas.height - p.height; }
    
    function performZoom(p, factor) {
        const minSize = 20; 
        const nw = p.width * factor;
        const nh = p.height * factor;
        if (Math.max(nw, nh) >= minSize) {
            p.x -= (nw - p.width) / 2;
            p.y -= (nh - p.height) / 2;
            p.width = nw;
            p.height = nh;
            checkBounds(p);
        }
    }

    function getPlayerUnderMouse(mx, my) {
        for (let i = activeObjects.length - 1; i >= 0; i--) { const p = activeObjects[i]; if (mx > p.x && mx < p.x + p.width && my > p.y && my < p.y + p.height) return i; } return -1;
    }

    function getLayer(p) {
        if (p.type === 'text') return 3; 
        if (p.type === 'rect') return 1;
        if (['tree', 'injured'].includes(p.assetKey)) return 1;
        if (['skiBlue', 'skiGreen', 'skiPlow', 'boarder'].includes(p.assetKey)) return 2;
        return 0; 
    }

    function openTextEditor(p) {
        if (!p || p.type !== 'text') return;
        const nt = prompt("Text Ã¤ndern:", p.text);
        if(nt !== null) { 
            p.text = nt; 
            ctx.font = 'bold ' + p.height + 'px Arial';
            const m = ctx.measureText(nt);
            p.width = m.width + 20; 
        }
    }

    function handleStart(x, y, isRight) {
        const idx = getPlayerUnderMouse(x, y);
        const now = Date.now();
        
        if (idx !== -1) {
            const p = activeObjects[idx]; activePlayerIndex = idx;
            
            // Double Tap Check (Time-based for Touch & Mouse)
            if (p.type === 'text' && (now - lastTapTime < 300)) {
                openTextEditor(p);
                lastTapTime = 0; // Reset
                return;
            }
            lastTapTime = now;

            if (isRight) { rotatingPlayerIndex = idx; isSnapping = false; }
            else { draggingPlayerIndex = idx; dragOffset.x = x - p.x; dragOffset.y = y - p.y; p.dx = 0; p.dy = 0; }
            return true;
        } 
        return false;
    }
    function handleMove(x, y) {
        const idx = getPlayerUnderMouse(x, y);
        if (draggingPlayerIndex !== -1) canvas.style.cursor = 'grabbing'; else if (idx !== -1) canvas.style.cursor = 'grab'; else canvas.style.cursor = 'default';
        if (draggingPlayerIndex !== -1) { const p = activeObjects[draggingPlayerIndex]; p.x = x - dragOffset.x; p.y = y - dragOffset.y; checkBounds(p); }
    }
    
    function triggerSnap(index) {
        if (index === -1) return;
        const p = activeObjects[index];
        targetRotation = Math.round(p.rotation / 15) * 15;
        isSnapping = true;
        snappingPlayerIndex = index;
    }

    function handleEnd(e) {
        let mx = e.clientX, my = e.clientY;
        if (e.changedTouches && e.changedTouches.length > 0) { mx = e.changedTouches[0].clientX; my = e.changedTouches[0].clientY; }
        const isRight = (e.button === 2);
        
        if (draggingPlayerIndex !== -1) {
            const dr = dockContainer.getBoundingClientRect();
            if (mx >= dr.left - 20 && mx <= dr.right + 20 && my >= dr.top - 20 && my <= dr.bottom + 20) {
                const p = activeObjects[draggingPlayerIndex];
                let ni = { type: p.type, width: p.width, height: p.height, rotation: (p.type==='sprite' && p.assetKey==='boarder') ? 90 : 0 };
                if(p.type === 'sprite') ni.assetKey = p.assetKey; 
                else if (p.type === 'text') { ni.text = p.text; ni.color = p.color; }
                else ni.color = p.color;
                dockedObjects.push(ni); activeObjects.splice(draggingPlayerIndex, 1); renderDock();
                draggingPlayerIndex = -1; activePlayerIndex = 0; return;
            }
        }
        
        draggingPlayerIndex = -1;
        if (isRight && rotatingPlayerIndex !== -1) {
            triggerSnap(rotatingPlayerIndex);
            rotatingPlayerIndex = -1;
        }
    }

    canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY, e.button === 2));
    canvas.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', e => handleEnd(e));
    canvas.addEventListener('contextmenu', e => { e.preventDefault(); return false; });
    
    // Mouse Wheel Zoom
    canvas.addEventListener('wheel', e => { 
        e.preventDefault(); 
        if(activeObjects.length) performZoom(activeObjects[activePlayerIndex], e.deltaY < 0 ? 1.1 : 0.9);
    }, { passive: false });
    
    canvas.addEventListener('touchstart', e => { if(e.target===canvas)e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY, false); }, { passive: false });
    canvas.addEventListener('touchmove', e => { if(e.target===canvas)e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
    canvas.addEventListener('touchend', e => handleEnd(e));

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, RotateLeft: false, RotateRight: false, ZoomIn: false, ZoomOut: false };
    
    function bindBtn(id, k) {
        const b = document.getElementById(id);
        const s = (e) => { e.preventDefault(); keys[k] = true; };
        const n = (e) => { 
            e.preventDefault(); keys[k] = false; 
            if (k === 'RotateLeft' || k === 'RotateRight') triggerSnap(activePlayerIndex);
        };
        b.addEventListener('mousedown', s); b.addEventListener('mouseup', n); b.addEventListener('mouseleave', n);
        b.addEventListener('touchstart', s, {passive:false}); b.addEventListener('touchend', n, {passive:false});
    }
    bindBtn('btnUp', 'ArrowUp'); bindBtn('btnDown', 'ArrowDown'); bindBtn('btnLeft', 'ArrowLeft'); bindBtn('btnRight', 'ArrowRight');
    bindBtn('btnRotLeft', 'RotateLeft'); bindBtn('btnRotRight', 'RotateRight'); bindBtn('btnZoomIn', 'ZoomIn'); bindBtn('btnZoomOut', 'ZoomOut');

    window.addEventListener('keydown', e => {
        if (e.key==='s'||e.key==='S') { document.getElementById('saveBtn').click(); return; }
        if (e.code==='Tab') { e.preventDefault(); if(activeObjects.length>1) activePlayerIndex=(activePlayerIndex+1)%activeObjects.length; return; }
        if (e.key==='Enter') {
            openTextEditor(activeObjects[activePlayerIndex]);
            return;
        }
        if(keys.hasOwnProperty(e.code)) keys[e.code]=true;
        if(e.key==='Ã¶'||e.key==='Ã–') keys['RotateLeft']=true; if(e.key==='Ã¤'||e.key==='Ã„') keys['RotateRight']=true;
        if(e.key==='+') keys['ZoomIn']=true; if(e.key==='-') keys['ZoomOut']=true;
    });
    
    window.addEventListener('keyup', e => {
        if ((e.key==='Ã¶'||e.key==='Ã–') || (e.key==='Ã¤'||e.key==='Ã„')) triggerSnap(activePlayerIndex);
        if(keys.hasOwnProperty(e.code)) keys[e.code]=false;
        if(e.key==='Ã¶'||e.key==='Ã–') keys['RotateLeft']=false; if(e.key==='Ã¤'||e.key==='Ã„') keys['RotateRight']=false;
        if(e.key==='+') keys['ZoomIn']=false; if(e.key==='-') keys['ZoomOut']=false;
    });

    document.getElementById('saveBtn').addEventListener('click', () => {
        const link = document.createElement('a'); link.download = `ski-sim-${Date.now()}.png`; link.href = canvas.toDataURL("image/png"); link.click();
    });

    // --- SHARE FUNCTIONALITY ---
    document.getElementById('shareBtn').addEventListener('click', async () => {
        if (navigator.share) {
            try {
                const dataUrl = canvas.toDataURL('image/png');
                const blob = await (await fetch(dataUrl)).blob();
                const file = new File([blob], 'skisim-sketch.png', { type: 'image/png' });
                await navigator.share({ title: 'Ski-Unfallskizze', text: 'Erstellt mit Ski-Simulation V58', files: [file] });
            } catch (err) { console.log('Teilen abgebrochen/fehlgeschlagen:', err); }
        } else { alert('Teilen wird von diesem Browser nicht unterstÃ¼tzt. Bitte nutze den Download-Button.'); }
    });

    function update() {
        if(activeObjects.length === 0) return;
        if(activePlayerIndex >= activeObjects.length) activePlayerIndex=0;
        
        if(rotatingPlayerIndex !== -1) activeObjects[rotatingPlayerIndex].rotation += 3;
        
        if(isSnapping && snappingPlayerIndex !== -1) {
            const p = activeObjects[snappingPlayerIndex], diff = targetRotation - p.rotation;
            if(Math.abs(diff) < 3.1) { p.rotation = targetRotation; isSnapping = false; snappingPlayerIndex = -1; } 
            else { p.rotation += (diff > 0 ? 3 : -3); }
        }
        
        const ap = activeObjects[activePlayerIndex];
        if(draggingPlayerIndex !== activePlayerIndex) {
            if(keys['ArrowLeft']) ap.dx = -ap.speed; else if(keys['ArrowRight']) ap.dx = ap.speed; else ap.dx *= 0.85; 
            if(keys['ArrowUp']) ap.dy = -ap.speed; else if(keys['ArrowDown']) ap.dy = ap.speed; else ap.dy *= 0.85; 
            ap.x += ap.dx; ap.y += ap.dy;
            if(keys['RotateLeft']) ap.rotation -= 3; if(keys['RotateRight']) ap.rotation += 3;
            if(keys['ZoomIn']) performZoom(ap, 1.02); if(keys['ZoomOut']) performZoom(ap, 0.98);
            checkBounds(ap);
        }
    }

    function drawObject(p) {
        ctx.save(); ctx.translate(p.x + p.width/2, p.y + p.height/2);
        ctx.rotate(p.rotation * Math.PI / 180);
        if (p.type === 'sprite') {
            const img = ASSETS[p.assetKey];
            try { if (img && img.complete) ctx.drawImage(img, -p.width/2, -p.height/2, p.width, p.height); } catch(e){ ctx.fillStyle = "rgba(0,0,0,0.1)"; ctx.fillRect(-p.width/2, -p.height/2, p.width, p.height); }
        } else if (p.type === 'text') {
            ctx.font = 'bold ' + p.height + 'px Arial';
            ctx.fillStyle = p.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.text, 0, 0);
        } else {
            ctx.fillStyle = p.color; ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 10; ctx.shadowOffsetY = 5;
            ctx.fillRect(-p.width/2, -p.height/2, p.width, p.height);
        }
        ctx.restore(); 
    }

    function drawLoop() {
        update();
        ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        let g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 100, canvas.width/2, canvas.height/2, canvas.width);
        g.addColorStop(0, 'rgba(255,255,255,0.2)'); g.addColorStop(1, '#ebeff5'); ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

        activeObjects.forEach(p => { if(getLayer(p) === 0) drawObject(p); });
        activeObjects.forEach(p => { if(getLayer(p) === 1) drawObject(p); });
        activeObjects.forEach(p => { if(getLayer(p) === 2) drawObject(p); });
        activeObjects.forEach(p => { if(getLayer(p) === 3) drawObject(p); });

        if(activeObjects.length > 0) {
            const p = activeObjects[activePlayerIndex];
            if(p) {
                ctx.save(); ctx.translate(p.x + p.width/2, p.y + p.height/2);
                ctx.beginPath(); ctx.arc(0, 0, Math.max(p.width, p.height)/1.4, 0, Math.PI*2);
                ctx.strokeStyle = '#00bfff'; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); ctx.stroke();
                ctx.restore();
            }
        }
        
        requestAnimationFrame(drawLoop);
    }

    preloadAssets(startGame);
</script>
</body>
</html>
